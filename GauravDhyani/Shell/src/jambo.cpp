// -
// Standard and Third-Party Includes
// -
#include <curl/curl.h>
#include <iostream>
#include <sstream>
#include <string>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "./include/json.hpp"
#include <regex> 
using json = nlohmann::json;
#ifdef __cplusplus
extern "C" {
#endif

#include "../JAM/lexer.h"
#include "../JAM/parser.h"
#include "../JAM/semanticanalyser.h"

#ifdef __cplusplus
}
#endif
// -
// Constants and Globals
// -
// Replace this with your actual Groq API key
const std::string API_KEY = "EnterYourGroqKey";

// -
// Stdout Capture Utilities
// -

/**
 * @brief Captures the stdout output generated by a callback function.
 * 
 * Redirects stdout to a pipe, executes the given function, restores stdout,
 * and returns the captured output as a newly allocated string.
 * 
 * @param func Function pointer whose output will be captured.
 * @param arg Argument to pass to the function.
 * @return char* Captured output string (malloc'ed, must be freed).
 */
// Capture printf/puts output produced during the callback function.
char* capture_stdout_output(void (*func)(void*), void* arg) {
    int pipefd[2];
    pipe(pipefd);

    int stdout_fd = dup(fileno(stdout));  // save original stdout
    dup2(pipefd[1], fileno(stdout));      // redirect stdout to pipe write end
    close(pipefd[1]);

    func(arg);  // execute function that uses printf

    fflush(stdout);
    dup2(stdout_fd, fileno(stdout));      // restore stdout
    close(stdout_fd);

    // Read captured output from pipe
    char buffer[16384];  // increase if needed
    ssize_t n = read(pipefd[0], buffer, sizeof(buffer) - 1);
    close(pipefd[0]);

    if (n < 0) n = 0;
    buffer[n] = '\0';

    char* output_str = (char*)malloc(n + 1);
    if (output_str) strcpy(output_str, buffer);
    return output_str;
}

// -
// AST Printing Callback Helpers
// -

/**
 * @brief Struct to hold arguments for printing the AST.
 */
typedef struct {
    ASTNode* ast;
    std::stringstream* output; // Only if you want to combine stringstream + printf output
} PrintASTArgs;

/**
 * @brief Callback function to print the AST to stdout.
 * 
 * @param arg Pointer to PrintASTArgs.
 */
void printAST_to_stdout(void* arg) {
    PrintASTArgs* args = (PrintASTArgs*)arg;
    printAST(args->ast, 0);
}

std::string sanitizeResponse(const std::string& input) {
    std::string output;
    for (char c : input) {
        // Skip soft hyphen and non-printable control characters
        if (static_cast<unsigned char>(c) == 0xAD) continue;
        output += c;
    }
    return output;
}
#include <iostream>
#include <sstream>
#include <regex>

void sanitizeAndPrettyPrintResponse(const std::string& input) {
    std::string sanitized;

    // Remove soft hyphens & convert escaped newlines to real newlines
    for (size_t i = 0; i < input.size(); ++i) {
        if (static_cast<unsigned char>(input[i]) == 0xAD) continue;
        if (input[i] == '\\' && i + 1 < input.size() && input[i + 1] == 'n') {
            sanitized += '\n';
            ++i;
        } else {
            sanitized += input[i];
        }
    }

    std::istringstream iss(sanitized);
    std::string line;
    bool insideCodeBlock = false;

    while (std::getline(iss, line)) {
        std::smatch match;

        // Markdown headings
        if (std::regex_search(line, match, std::regex("^###\\s*(.*)"))) {
            line = "\x1B[1;34m" + match[1].str() + "\x1B[0m";
        }
        // Bold lines
        else if (std::regex_search(line, match, std::regex("^\\*\\*\\s*(.*)\\s*\\*\\*"))) {
            line = "\x1B[1;32m" + match[1].str() + "\x1B[0m";
        }
        // Bullets
        else if (std::regex_search(line, match, std::regex("^\\*\\s+(.*)"))) {
            line = "- " + match[1].str();
        }
        // Inline code
        line = std::regex_replace(line, std::regex("`([^`]*)`"), "\x1B[1;36m$1\x1B[0m");

        // Code block markers
        if (line.find("```") != std::string::npos) {
            insideCodeBlock = !insideCodeBlock;
            if (insideCodeBlock) {
                std::cout << "\x1B[1;33m\n------------------- CODE BLOCK -------------------\x1B[0m\n";
            } else {
                std::cout << "\x1B[1;33m----------------- END CODE BLOCK -----------------\x1B[0m\n\n";
            }
            continue;
        }

        std::cout << line << std::endl;
    }
}



/**
 * @brief Struct to hold arguments for semantic debug traversal.
 */
typedef struct {
    ASTNode* ast;
} DebugTraverseArgs;

/**
 * @brief Callback function to perform semantic analysis debug output.
 * 
 * @param arg Pointer to DebugTraverseArgs.
 */
void debugTraverse_to_stdout(void* arg) {
    DebugTraverseArgs* args = (DebugTraverseArgs*)arg;
    printf("===== Semantic Analysis =====\n");
    debugTraverse(args->ast);
    printf("Semantic analysis completed successfully.\n\n");
}

// -
// CURL Helper Functions
// -

/**
 * @brief CURL write callback to append data to a std::string.
 * 
 * @param contents Pointer to received data.
 * @param size Size of each data element.
 * @param nmemb Number of elements.
 * @param output Pointer to std::string to append data.
 * @return size_t Number of bytes processed.
 */
// Callback to write response into a string
size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* output) {
    size_t totalSize = size * nmemb;
    output->append((char*)contents, totalSize);
    return totalSize;
}

/**
 * @brief Sends a chat request to the Groq API with a given user message.
 * 
 * Prepares the payload with JAM syntax reference, sends the request, and
 * returns the response as a JSON string.
 * 
 * @param userMessage The user input message to send.
 * @return std::string JSON response from the API.
 */
// Function to send a chat request to the Groq API
std::string callGroqAPI(const std::string& userMessage) {
    CURL* curl = curl_easy_init();
    std::string response_string;

    if (curl) {
        std::string jamPrompt = R"(Syntax Design for JAM:
- Token separators: space, \t, \n, \r\n  
- Comments: ** single-line, *- ... -* multiline  
- Keywords: fn, if, else, var, return, import, loop, forloop  
- Identifiers: [A-Za-z_][A-Za-z0-9_]*  
- Literals: Integer (\d+), Float (\d+\.\d+), String ("..." with escapes)  
- Operators: +, -, *, /, %, =, ==, !=, <, <=, >, >=, &&, ||, !  
- Arrow (return type): ->  
- Delimiters: ( ) { } [ ], :, ;, .  
- Data types: Int, Float, Bool, String, Void  
- Arrays: var arr:[Int]=[1,2,3,4]  
- Tuples: var p:(Int,Int)=(10,20)  
- Structs: struct p { name:String, age:Int }  

### Example Function:

```jam
var arr: [Int] = [1, 2, 3, 4];

var i: Int = 0;
print("loop");

while (i < 10) {
    i = i + 1;
    print(i);
}

print("Factorial of 5:");

var result: Int = factorial(5);
print(result);

fn factorial(n: Int) -> Int {
    if (n <= 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
Built by Jai,Vibhor,Gaurav
)";

        json payload = {
            {"model", "meta-llama/llama-4-scout-17b-16e-instruct"},
            {"messages", {
                {{"role", "system"}, {"content", "You are JAMBO - an expert on the JAM compiler project. Hereâ€™s the full JAM syntax reference and a sample factorial function:\n" + jamPrompt + "\nWhen the user asks questions, provide clear, concise guidance on lexer/parser design, AST construction, syntax rules, or debugging examples."}},
                {{"role", "user"}, {"content", userMessage}}
            }},
            {"temperature", 0.7}
        };

        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers, ("Authorization: Bearer " + API_KEY).c_str());
        headers = curl_slist_append(headers, "Content-Type: application/json");

        curl_easy_setopt(curl, CURLOPT_URL, "https://api.groq.com/openai/v1/chat/completions");
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload.dump().c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_string);
        std::string payload_str = payload.dump();

        CURLcode res = curl_easy_perform(curl);
        if (res != CURLE_OK) {
            std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << "\n";
        } 
        curl_easy_cleanup(curl);
        curl_slist_free_all(headers);
    }

    return response_string;
}


// -
// JAMBO Main Interactive Loop
// -

/**
 * @brief Runs the JAMBO interactive shell for asking questions about JAM.
 * 
 * Prompts the user for input, sends queries to Groq API, and prints responses.
 * Typing 'exit' or 'quit' ends the session.
 * 
 * @return int Exit status.
 */
void run_jambo() {
    std::cout << "Welcome to JAMBO! Ask me anything about the JAM compiler language.\n";

    std::string userInput;
    while (true) {
        std::cout << "\nJAM Question> ";
        std::getline(std::cin, userInput);

        if (userInput.empty() || userInput == "exit" || userInput == "quit") {
            std::cout << "Goodbye!\n";
            break;
        }

        // Call Groq API
        std::string response = callGroqAPI(userInput);

        try {
            // Sanitize the raw response JSON string
            std::string sanitizedResponse = sanitizeResponse(response);

            // Parse the sanitized JSON
            auto jsonResponse = json::parse(sanitizedResponse);

            // Extract message content
            std::string reply = jsonResponse["choices"][0]["message"]["content"];

            // Pretty print the reply
            std::cout << "\n\033[1;32mJAMBO:\033[0m\n";
            sanitizeAndPrettyPrintResponse(reply);

        } catch (const std::exception& e) {
            std::cerr << "Failed to parse response:\n" << response << "\n";
            std::cerr << "Error: " << e.what() << "\n";
        }
    }
}

// -
// Lexer Analysis Function
// -

/**
 * @brief Analyzes the lexical tokens of the given source file.
 * 
 * Opens the file, reads source code, runs the lexer to produce tokens,
 * prints tokens, sends lexer output and source code to Groq API for analysis,
 * and prints the API response.
 * 
 * @param filename Path to the source file to analyze.
 */
void analyse_lexer(const char* filename) {
    FILE* file = fopen(filename, "r");
    if (!file) { perror("Script open error"); return; }
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    rewind(file);
    char* source_code = (char*)malloc(size + 1);
    fread(source_code, 1, size, file);
    source_code[size] = '\0';
    fclose(file);

    std::stringstream output;
    initlexer(source_code);
    output << "Tokens:\n";
    while (1) {
        Token* t = get_next_token();
        output << "Token(type=" << (int)t->type << ", lexeme='" << t->lexeme
               << "', line=" << t->line << ", col=" << t->col << ")\n";
        if (t->type == TOKEN_EOF) {
            free(t->lexeme);
            free(t);
            break;
        }
        free(t->lexeme);
        free(t);
    }
    std::cout << "\n===== Lexer Output =====\n" << output.str() << std::endl;
    std::string groq_input = "Debug Lexer analysis of file:\n" + output.str() + "\n\nSource code:\n" + source_code;
    std::string response = callGroqAPI(groq_input);
     try {
            // Sanitize the raw response JSON string
            std::string sanitizedResponse = sanitizeResponse(response);

            // Parse the sanitized JSON
            auto jsonResponse = json::parse(sanitizedResponse);

            // Extract message content
            std::string reply = jsonResponse["choices"][0]["message"]["content"];

            // Pretty print the reply
            std::cout << "\n\033[1;32mJAMBO:\033[0m\n";
            sanitizeAndPrettyPrintResponse(reply);

        } catch (const std::exception& e) {
            std::cerr << "Failed to parse response:\n" << response << "\n";
            std::cerr << "Error: " << e.what() << "\n";
        }

    free(source_code);
}

// -
// Parser Analysis Function
// -

/**
 * @brief Analyzes the parser AST of the given source file.
 * 
 * Reads source code, tokenizes it, parses to an AST,
 * captures the AST print output, sends it with source code to Groq API,
 * then prints the API response.
 * 
 * @param filename Path to the source file to analyze.
 */
void analyse_parser(const char* filename) {
    FILE* file = fopen(filename, "r");
    if (!file) { perror("Script open error"); return; }
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    rewind(file);
    char* source_code = (char*)malloc(size + 1);
    fread(source_code, 1, size, file);
    source_code[size] = '\0';
    fclose(file);

    initlexer(source_code);
    Token** tokens = NULL;
    int count = 0, cap = 0;
    while (1) {
        Token* t = get_next_token();
        if (count == cap) {
            cap = cap ? cap * 2 : 8;
            tokens = (Token**)realloc(tokens, cap * sizeof(Token*));
        }
        tokens[count++] = t;
        if (t->type == TOKEN_EOF) break;
    }

    Parser parser;
    initParser(&parser, tokens, count);
    ASTNode* ast = parseProgram(&parser);

    // Capture printAST output
    PrintASTArgs args = { ast, nullptr };
    char* captured_output = capture_stdout_output(printAST_to_stdout, &args);

    freeAST(ast);
    for (int i = 0; i < count; i++) {
        free(tokens[i]->lexeme);
        free(tokens[i]);
    }
    free(tokens);
    std::cout << "\n===== Parser Output =====\n" << captured_output << std::endl;
    std::string groq_input = std::string("Debug Parser analysis of file:\n") + (captured_output ? captured_output : "") + "\n\nSource code:\n" + source_code;
    std::string response = callGroqAPI(groq_input);
     try {
            // Sanitize the raw response JSON string
            std::string sanitizedResponse = sanitizeResponse(response);

            // Parse the sanitized JSON
            auto jsonResponse = json::parse(sanitizedResponse);

            // Extract message content
            std::string reply = jsonResponse["choices"][0]["message"]["content"];

            // Pretty print the reply
            std::cout << "\n\033[1;32mJAMBO:\033[0m\n";
            sanitizeAndPrettyPrintResponse(reply);

        } catch (const std::exception& e) {
            std::cerr << "Failed to parse response:\n" << response << "\n";
            std::cerr << "Error: " << e.what() << "\n";
        }

    free(source_code);
    free(captured_output);
}

// -
// Semantic Analysis Function
// -
void analyse_semantics(const char* filename) {
    FILE* file = fopen(filename, "r");
    if (!file) { perror("Script open error"); return; }
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    rewind(file);
    char* source_code = (char*)malloc(size + 1);
    fread(source_code, 1, size, file);
    source_code[size] = '\0';
    fclose(file);

    initlexer(source_code);
    Token** tokens = NULL;
    int count = 0, cap = 0;
    while (1) {
        Token* t = get_next_token();
        if (count == cap) {
            cap = cap ? cap * 2 : 8;
            tokens = (Token**)realloc(tokens, cap * sizeof(Token*));
        }
        tokens[count++] = t;
        if (t->type == TOKEN_EOF) break;
    }

    Parser parser;
    initParser(&parser, tokens, count);
    ASTNode* ast = parseProgram(&parser);

    // Capture debugTraverse output
    DebugTraverseArgs args = { ast };
    char* captured_output = capture_stdout_output(debugTraverse_to_stdout, &args);

    freeAST(ast);
    for (int i = 0; i < count; i++) {
        free(tokens[i]->lexeme);
        free(tokens[i]);
    }
    free(tokens);
    std::cout << "\n=====  Semantic Analyser Output =====\n" << captured_output << std::endl;
    std::string groq_input = std::string("Debug Semantic analysis of file:\n") + (captured_output ? captured_output : "") + "\n\nSource code:\n" + source_code;
    std::string response = callGroqAPI(groq_input);
     try {
            // Sanitize the raw response JSON string
            std::string sanitizedResponse = sanitizeResponse(response);

            // Parse the sanitized JSON
            auto jsonResponse = json::parse(sanitizedResponse);

            // Extract message content
            std::string reply = jsonResponse["choices"][0]["message"]["content"];

            // Pretty print the reply
            std::cout << "\n\033[1;32mJAMBO:\033[0m\n";
            sanitizeAndPrettyPrintResponse(reply);

        } catch (const std::exception& e) {
            std::cerr << "Failed to parse response:\n" << response << "\n";
            std::cerr << "Error: " << e.what() << "\n";
        }

    free(source_code);
    free(captured_output);
}
